function [bingrid, shape] = improcess(rawim)
%IMROCESS Processes the image to prepare it for an HMM

% Number of segments
NSEGR = 3;
NSEGC = 3;
% Size of the grids
NRGRIDCELL = 3;
NCGRIDCELL = 3;
% Number of grids
NRWHOLEGRID = NSEGR*NRGRIDCELL;
NCWHOLEGRID = NSEGC*NCGRIDCELL;
% The percentage of the pixels in a map that are allowed to be white
% before we count on the map as a colored one
THRESH = .35;
% Value for each pixel to be counted on as white (a piece of the shape)
THETA = .2;

% THE CODE

%Crop to text area
[~, ~, ~, ~, negative] = bbox( rawim );
%Resize the image to size of NRWHOLEGRID to NCWHOLEGRID (size of the shape)
%imresize does the pixel interpolation automatically, so there are no
%leftover cells
resized = imresize(negative, [NRWHOLEGRID NCWHOLEGRID]);
%Threshold and achieve binary image
shape = (1-resized)>THETA;

bingrid = zeros( NSEGR, NSEGC );

for i = 1 : NRWHOLEGRID
    for j = 1 : NCWHOLEGRID
        bingrid(floor(i/NR

%{
for i = 1:NSEGR
    for j = 1:NSEGC
        for k = 1:NRGRIDCELL
            for l = 1:NCGRIDCELL
                fstrow = ( ( i-1 )*NRGRIDCELL+k-1 )*NRMAP+1;
                lstrow = fstrow + NRMAP - 1;
                fstcol = ( ( j-1 )*NCGRIDCELL+l-1 )*NCMAP+1;
                lstcol = fstcol + NCMAP - 1;
                
                shape( ( i-1 )*NRGRIDCELL+k,( j-1 )*NCGRIDCELL+l ) = ...
                    ( sum( sum( imcrop( fstrow:lstrow, fstcol:lstcol ) ) )...
                    /maparea > THRESH );
                bingrid( i, j ) = bingrid( i, j )*2+...
                    shape( ( i-1 )*NRGRIDCELL+k,( j-1 )*NCGRIDCELL+l );
            end
        end
    end
end
%}